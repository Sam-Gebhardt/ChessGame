/* holds the values for each piece at a specific place on the board

https://www.adamberent.com/2019/03/02/piece-square-table/
*/

fn pawn(pos: [i8; 2]) -> i32 {

    let PawnTable: [[i32; 8]; 8] = [
        [0,  0,  0,  0,  0,  0,  0,  0],
        [50, 50, 50, 50, 50, 50, 50, 50],
        [10, 10, 20, 30, 30, 20, 10, 10],
        [5,  5, 10, 27, 27, 10,  5,  5],
        [0,  0,  0, 25, 25,  0,  0,  0],
        [5, -5,-10,  0,  0,-10, -5,  5],
        [5, 10, 10,-25,-25, 10, 10,  5],
        [0,  0,  0,  0,  0,  0,  0,  0]];

    return PawnTable[pos[0] as usize][pos[1] as usize];
}

fn knight(pos: [i8; 2]) -> i32 {

    let KnightTable: [[i32; 8]; 8] = [
        [-50,-40,-30,-30,-30,-30,-40,-50],
        [-40,-20,  0,  0,  0,  0,-20,-40],
        [-30,  0, 10, 15, 15, 10,  0,-30],
        [-30,  5, 15, 20, 20, 15,  5,-30],
        [-30,  0, 15, 20, 20, 15,  0,-30],
        [-30,  5, 10, 15, 15, 10,  5,-30],
        [-40,-20,  0,  5,  5,  0,-20,-40],
        [-50,-40,-20,-30,-30,-20,-40,-50]];
    
    return KnightTable[pos[0] as usize][pos[1] as usize];
}

fn bishop(pos: [i8; 2]) -> i32 {

    let BishopTable: [[i32; 8]; 8] = [
        [-20,-10,-10,-10,-10,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5, 10, 10,  5,  0,-10],
        [-10,  5,  5, 10, 10,  5,  5,-10],
        [-10,  0, 10, 10, 10, 10,  0,-10],
        [-10, 10, 10, 10, 10, 10, 10,-10],
        [-10,  5,  0,  0,  0,  0,  5,-10],
        [-20,-10,-40,-10,-10,-40,-10,-20]];

    return BishopTable[pos[0] as usize][pos[1] as usize];
}

fn king(pos: [i8; 2]) -> i32 {

    let KingTable: [[i32: 8]; 8] = [
        [-30, -40, -40, -50, -50, -40, -40, -30],
        [-30, -40, -40, -50, -50, -40, -40, -30],
        [-30, -40, -40, -50, -50, -40, -40, -30],
        [-30, -40, -40, -50, -50, -40, -40, -30],
        [-20, -30, -30, -40, -40, -30, -30, -20],
        [-10, -20, -20, -20, -20, -20, -20, -10], 
        [20,  20,   0,   0,   0,   0,  20,  20],
        [20,  30,  10,   0,   0,  10,  30,  20]];

        return KingTable[pos[0] as usize][pos[1] as usize];
}

    // let KingTableEndGame: [[i32; 8]; 8] = [
    //     [-50,-40,-30,-20,-20,-30,-40,-50],
    //     [-30,-20,-10,  0,  0,-10,-20,-30],
    //     [-30,-10, 20, 30, 30, 20,-10,-30],
    //     [-30,-10, 30, 40, 40, 30,-10,-30],
    //     [-30,-10, 30, 40, 40, 30,-10,-30],
    //     [-30,-10, 20, 30, 30, 20,-10,-30],
    //     [-30,-30,  0,  0,  0,  0,-30,-30],
    //     [-50,-30,-30,-30,-30,-30,-30,-50]];


fn find_piece(key: i8, pos: [i8; 2]) -> i32 {

    // Queens/towers don't seem to have positioal advantage
    let p = match key {
        1 => pawn(pos),
        3 => knight(pos),
        4 => bishop(pos),
        6 => king(pos), 
        _ => 0
    };
    
    return p;
}


// Evaluate the value of a piece based on its type 
// and position
pub fn eval_piece(key: i8, pos: [i8; 2]) {
    
    find_piece(key, pos);

} 